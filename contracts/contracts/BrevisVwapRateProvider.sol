// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import './lib/BrevisApp.sol';
import './interfaces/IVwapRateProvider.sol';

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

struct ChainInfo {
    uint256 baseVolume;
    uint256 quoteVolume;
    uint256 expiresAt;
}

contract BrevisVwapRateProvider is IVwapRateProvider, BrevisApp, Ownable {

    event SwapVolumeAttested(uint256 indexed chainId, uint256 baseVolume, uint256 quoteVolume);

    address immutable baseToken;
    address immutable quoteToken;

    uint256 immutable baseTokenScalingFactor;
    uint256 immutable quoteTokenScalingFactor;

    bytes32 public vkHash;
    uint256 public timeout;
    uint256[] public chains;

    mapping(uint256 => ChainInfo) public chainData;

    constructor(
        address brevisRequest, 
        address _baseToken, 
        address _quoteToken
    ) BrevisApp(brevisRequest) Ownable(msg.sender) {
        baseToken = _baseToken;
        quoteToken = _quoteToken;

        baseTokenScalingFactor = 10**(18-IERC20Metadata(_baseToken).decimals());
        quoteTokenScalingFactor = 10**(18-IERC20Metadata(_quoteToken).decimals());
    }

    // calculate vwap using submitted base and quote volumes across cross chain defi ecosystem
    // ignores submissions that have passed their timeout
    function vwap() public view returns (bool, uint256) {
        uint256 baseVolume;
        uint256 quoteVolume;

        uint256[] memory _chains = chains;

        for(uint256 i = 0; i < _chains.length; i++){
            ChainInfo memory info = chainData[_chains[i]];

            if(info.expiresAt < block.timestamp) {
                continue;
            }

            baseVolume += info.baseVolume;
            quoteVolume += info.quoteVolume;
        }

        if(baseVolume * quoteVolume == 0) {
            return (false, 0);
        }

        uint256 price = Math.mulDiv(baseVolume, 1e18, quoteVolume);

        return (true, price);
    }

    // BrevisRequest contract will trigger callback once ZK proof is received.
    function handleProofResult(
        bytes32 _vkHash, 
        bytes calldata _circuitOutput
    ) internal override {
        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed
        // our designated verifying key. This proves that the _circuitOutput is authentic
        require(vkHash == _vkHash, "invalid vk");

        (uint256 chainId, uint256 baseVolume, uint256 quoteVolume) = decodeOutput(_circuitOutput);
        
        emit SwapVolumeAttested(chainId, baseVolume, quoteVolume);

        chainData[chainId] = ChainInfo(baseVolume, quoteVolume, block.timestamp);
    }

    // In app circuit we have:
    // api.OutputUint(248, chainId)
    // api.OutputUint(248, baseTokenVolume)
    // api.OutputUint(248, quoteTokenVolume)
    function decodeOutput(
        bytes calldata o
    ) internal view returns (uint256 chainId, uint256 baseVolume, uint256 quoteVolume) {
        chainId = uint256(uint248(bytes31(o[0:31]))); 
        baseVolume = uint256(uint248(bytes31(o[31:62]))) * baseTokenScalingFactor;
        quoteVolume = uint256(uint248(bytes31(o[62:93]))) * quoteTokenScalingFactor;
    }

    // handle optimistic proof result.
    function handleOpProofResult(
        bytes32 _vkHash, 
        bytes calldata _circuitOutput
    ) internal override {
        handleProofResult(_vkHash, _circuitOutput);
    }

    // chains which we will consider for vwap computations
    function setChains(
        uint256[] calldata _chains
    ) external onlyOwner {
        chains = _chains;
    }

    // vkHash represents the unique circuit app logic
    function setVkHash(
        bytes32 _vkHash
    ) external onlyOwner {
        vkHash = _vkHash;
    }
}